<?php

/**
 * JsonToPhpCompiler
 * 
 * Compiles JSON page structures into static PHP code for production builds.
 * Converts JSON nodes into PHP string concatenation with translator calls.
 */
class JsonToPhpCompiler {
    
    /**
     * Compile a full page JSON structure to PHP code
     * 
     * @param array $structure The page JSON structure
     * @param string $pageTitle The page title key for translation
     * @param bool $showMenu Whether to show the menu (default: true)
     * @param bool $showFooter Whether to show the footer (default: true)
     * @return string The compiled PHP code
     */
    public function compilePage(array $structure, string $pageTitle, bool $showMenu = true, bool $showFooter = true, array $pageEvents = []): string {
        $output = "<?php\n\n";
        $output .= "require_once SECURE_FOLDER_PATH . '/src/classes/TrimParameters.php';\n";
        $output .= "\$trimParameters = new TrimParameters();\n";
        $output .= "require_once SECURE_FOLDER_PATH . '/src/classes/Translator.php';\n";
        $output .= "\$translator = new Translator(\$trimParameters->lang());\n";
        $output .= "\$lang = \$trimParameters->lang();\n\n";
        
        // Add system variables for placeholders
        $output .= $this->generateSystemVariables();
        
        // Generate title from translation using page title parameter
        $output .= "// Get page title from translation\n";
        $output .= "\$pageTitle = \$translator->translate('page.titles.{$pageTitle}');\n\n";
        $output .= "\$content = '';\n";
        $output .= $this->compileNodes($structure);
        
        // Compile page-level events (onload, onresize, onscroll) into a script tag
        $pageEventsScript = $this->compilePageEvents($pageEvents);
        
        // Pass layout settings to Page constructor
        $showMenuStr = $showMenu ? 'true' : 'false';
        $showFooterStr = $showFooter ? 'true' : 'false';
        $pageEventsScriptStr = addcslashes($pageEventsScript, "'\\");
        
        $output .= "\nrequire_once SECURE_FOLDER_PATH . '/src/classes/Page.php';\n";
        $output .= "\$page = new Page(\$pageTitle, \$content, \$lang, {$showMenuStr}, {$showFooterStr}, '{$pageEventsScriptStr}');\n";
        $output .= "\$page->render();\n";
        
        return $output;
    }
    
    /**
     * Compile page-level events into a <script> tag
     * 
     * Converts page-events.json entries for a single route into JavaScript event listeners.
     * - onload → document.addEventListener("DOMContentLoaded", ...)
     * - onresize → window.addEventListener("resize", ...)
     * - onscroll → window.addEventListener("scroll", ...)
     * 
     * @param array $events The events for one page route, e.g. ['onload' => ['{{call:show:#modal}}']]
     * @return string The compiled <script> tag, or empty string if no events
     */
    public function compilePageEvents(array $events): string {
        if (empty($events)) {
            return '';
        }
        
        $eventScripts = [];
        
        // Map event names to their JS listener wrappers
        $eventMap = [
            'onload' => ['target' => 'document', 'event' => 'DOMContentLoaded'],
            'onresize' => ['target' => 'window', 'event' => 'resize'],
            'onscroll' => ['target' => 'window', 'event' => 'scroll'],
        ];
        
        foreach ($eventMap as $eventName => $listener) {
            if (!empty($events[$eventName]) && is_array($events[$eventName])) {
                $calls = [];
                foreach ($events[$eventName] as $callSyntax) {
                    $transformed = $this->transformCallSyntax($callSyntax);
                    // Only include valid transformed QS calls (skip unchanged or invalid)
                    if ($transformed && $transformed !== $callSyntax && strpos($transformed, '/* invalid') === false) {
                        $calls[] = $transformed;
                    }
                }
                if (!empty($calls)) {
                    $eventScripts[] = $listener['target'] . '.addEventListener("' . $listener['event'] . '",function(){' . implode(';', $calls) . '});';
                }
            }
        }
        
        if (empty($eventScripts)) {
            return '';
        }
        
        return '<script>' . implode('', $eventScripts) . '</script>';
    }
    
    /**
     * Compile menu/footer JSON structure to PHP code
     */
    public function compileMenuOrFooter(array $structure): string {
        $output = "<?php\n";
        $output .= "// This file is auto-generated by build command\n\n";
        
        // Add translator context
        $output .= "require_once SECURE_FOLDER_PATH . '/src/classes/TrimParameters.php';\n";
        $output .= "\$trimParameters = new TrimParameters();\n";
        $output .= "require_once SECURE_FOLDER_PATH . '/src/classes/Translator.php';\n";
        $output .= "\$translator = new Translator(\$trimParameters->lang());\n";
        $output .= "\$lang = \$trimParameters->lang();\n\n";
        
        // Add system variables for placeholders
        $output .= $this->generateSystemVariables();
        
        $output .= $this->compileNodes($structure, true);
        return $output;
    }
    
    /**
     * Generate PHP code for system variables ({{__placeholder}} support)
     */
    private function generateSystemVariables(): string {
        $output = "// System variables for {{__placeholder}} support\n";
        $output .= "\$__current_page = trim(parse_url(\$_SERVER['REQUEST_URI'], PHP_URL_PATH), '/');\n\n";
        
        // Remove PUBLIC_FOLDER_SPACE prefix
        $output .= "if (defined('PUBLIC_FOLDER_SPACE') && PUBLIC_FOLDER_SPACE !== '') {\n";
        $output .= "    \$__current_page = preg_replace('/^' . preg_quote(PUBLIC_FOLDER_SPACE, '/') . '\\\\\\\\/', '', \$__current_page);\n";
        $output .= "}\n\n";
        
        // Remove language prefix
        $output .= "if (defined('CONFIG') && isset(CONFIG['LANGUAGES_SUPPORTED'])) {\n";
        $output .= "    \$__current_page = preg_replace('/^(' . implode('|', CONFIG['LANGUAGES_SUPPORTED']) . ')\\\\\\\\/', '', \$__current_page);\n";
        $output .= "} else {\n";
        $output .= "    \$__current_page = preg_replace('/^(en|fr)\\\\\\\\/', '', \$__current_page);\n";
        $output .= "}\n\n";
        $output .= "\$__current_page = empty(\$__current_page) ? '' : \$__current_page;\n";
        $output .= "\$__lang = \$lang;\n";
        $output .= "\$__base_url = defined('BASE_URL') ? BASE_URL : '';\n";
        $output .= "\$__public_folder = defined('PUBLIC_FOLDER_NAME') ? PUBLIC_FOLDER_NAME : 'public';\n";
        $output .= "\$__current_route = basename(parse_url(\$_SERVER['REQUEST_URI'], PHP_URL_PATH));\n";
        $output .= "\$__space = (defined('PUBLIC_FOLDER_SPACE') && PUBLIC_FOLDER_SPACE !== '') ? '/' . PUBLIC_FOLDER_SPACE : '';\n\n";
        
        // Add processUrl helper function WITH function_exists check
        $output .= <<<'PHP'
    // Helper function to process URLs (add language prefix, handle absolute URLs)
    if (!function_exists('processUrl')) {
        function processUrl($url, $lang) {
            // Don't modify absolute URLs (http://, https://, //)
            if (preg_match('/^(https?:)?\/\//i', $url)) {
                return $url;
            }
            
            // Block dangerous protocols
            if (preg_match('/^(javascript|data|vbscript):/i', $url)) {
                return '#';
            }
            
            // Don't modify anchors, mailto, tel, etc.
            if (preg_match('/^(#|mailto:|tel:)/i', $url)) {
                return $url;
            }
            
            // Don't add language to asset paths
            if (preg_match('/^\/(assets|style)\//i', $url)) {
                return (defined('BASE_URL') ? BASE_URL : '') . ltrim($url, '/');
            }
            
            // Build URL with language prefix
            $fullUrl = defined('BASE_URL') ? BASE_URL : '';
            if (defined('MULTILINGUAL_SUPPORT') && MULTILINGUAL_SUPPORT && !empty($lang)) {
                // Don't add language if URL already starts with a language code
                $supportedLangs = defined('CONFIG') && isset(CONFIG['LANGUAGES_SUPPORTED']) ? CONFIG['LANGUAGES_SUPPORTED'] : ['en', 'fr'];
                $langPattern = '/^\\/(' . implode('|', $supportedLangs) . ')(\\/|$)/';
                if (!preg_match($langPattern, $url)) {
                    $fullUrl .= $lang . '/';
                }
            }
            $fullUrl .= ltrim($url, '/');
            
            // If URL is now empty (was "/" for home), fullUrl already has proper ending
            if (empty(ltrim($url, '/'))) {
                // fullUrl already ends with trailing slash (from BASE_URL or lang/)
                return $fullUrl;
            }
            
            // Ensure trailing slash if URL is just language code
            if (preg_match('/^(en|fr)$/i', ltrim($url, '/'))) {
                $fullUrl .= '/';
            }
            
            return $fullUrl;
        }
    }
    
    // Helper function to build language switch URLs
    if (!function_exists('buildLanguageSwitchUrl')) {
        function buildLanguageSwitchUrl($targetLang) {
            // Use TrimParameters to parse current URL and generate proper URL
            require_once SECURE_FOLDER_PATH . '/src/classes/TrimParameters.php';
            $trimParams = new TrimParameters();
            
            // Check if current page is valid (not 404)
            if ($trimParams->page() === '404') {
                // Invalid route - redirect to home in target language
                $url = defined('BASE_URL') ? BASE_URL : '';
                if (defined('MULTILINGUAL_SUPPORT') && MULTILINGUAL_SUPPORT) {
                    $url .= $targetLang . '/';
                }
                return $url;
            }
            
            // Valid route - use TrimParameters to build URL with target language
            return $trimParams->samePageUrl($targetLang);
        }
    }

    PHP;
        
        return $output;
    }
    
    /**
     * Compile an array of nodes to PHP code
     */
    private function compileNodes(array $nodes, bool $echo = false): string {
        $output = '';
        foreach ($nodes as $node) {
            $output .= $this->compileNode($node, $echo);
        }
        return $output;
    }
    
    /**
     * Compile a single node to PHP code
     */
    private function compileNode(array $node, bool $echo = false): string {
        // Handle component node
        if (isset($node['component'])) {
            return $this->compileComponent($node, $echo);
        }
        
        // Handle text node
        if (isset($node['textKey'])) {
            return $this->compileTextNode($node, $echo);
        }
        
        // Handle tag node
        if (isset($node['tag'])) {
            return $this->compileTagNode($node, $echo);
        }
        
        return "// Unknown node type\n";
    }
    
    /**
     * Compile a text node to PHP code
     */
    private function compileTextNode(array $node, bool $echo = false): string {
        $textKey = $node['textKey'];
        $prefix = $echo ? 'echo ' : '$content .= ';
        
        if (strpos($textKey, '__RAW__') === 0) {
            // Raw text
            $rawText = substr($textKey, 7);
            return $prefix . 'htmlspecialchars(' . var_export($rawText, true) . ', ENT_QUOTES | ENT_HTML5, \'UTF-8\');' . "\n";
        } else {
            // Translation key
            return $prefix . 'htmlspecialchars($translator->translate(' 
                   . var_export($textKey, true) 
                   . '), ENT_QUOTES | ENT_HTML5, \'UTF-8\');' . "\n";
        }
    }
    
    /**
     * Compile a tag node to PHP code
     */
    private function compileTagNode(array $node, bool $echo = false): string {
        $tag = $node['tag'];
        $params = $node['params'] ?? [];
        $children = $node['children'] ?? [];
        $prefix = $echo ? 'echo ' : '$content .= ';
        
        $output = '';
        
        // Build opening tag with attributes
        if (empty($params)) {
            // Simple tag without attributes
            $output .= $prefix . '"<' . $tag . '>";' . "\n";
        } else {
            // Tag with attributes - need to handle system placeholders
            $output .= $prefix . '"<' . $tag;
            
            // URL attributes that need processing
            $urlAttributes = ['href', 'src', 'data', 'poster', 'action', 'formaction', 'cite', 'srcset'];
            
            foreach ($params as $attrName => $attrValue) {
                // Handle event handler attributes (on*) - only allow {{call:...}} syntax
                if (preg_match('/^on[a-z]+$/i', $attrName)) {
                    if (is_string($attrValue) && strpos($attrValue, '{{call:') !== false) {
                        $transformedValue = $this->transformCallSyntax($attrValue);
                        if ($this->isValidTransformedHandler($transformedValue)) {
                            $output .= ' ' . $attrName . '=\\"" . htmlspecialchars(';
                            $output .= var_export($transformedValue, true);
                            $output .= ', ENT_QUOTES | ENT_HTML5, \'UTF-8\') . "\\"';
                        }
                        // Skip if transformation failed (blocked)
                    }
                    // Skip raw JS event handlers (blocked)
                    continue;
                }
                
                // Check if this is a URL attribute that needs language prefix
                $needsUrlProcessing = in_array($attrName, $urlAttributes, true);
                
                // Check if value contains system placeholders
                if (is_string($attrValue) && strpos($attrValue, '{{__') !== false) {
                    // Contains system placeholder - generate dynamic PHP
                    $phpValue = $this->convertPlaceholdersToPhp($attrValue);
                    
                    // Check if this is a buildLanguageSwitchUrl() call - these return complete URLs
                    $isLanguageSwitch = strpos($phpValue, 'buildLanguageSwitchUrl(') !== false;
                    
                    if ($needsUrlProcessing && !$isLanguageSwitch) {
                        // Wrap with processUrl function (but not for language switch URLs)
                        $output .= ' ' . $attrName . '=\\"" . htmlspecialchars(processUrl(' . $phpValue . ', $__lang), ENT_QUOTES | ENT_HTML5, \'UTF-8\') . "\\"';
                    } else {
                        $output .= ' ' . $attrName . '=\\"" . htmlspecialchars(' . $phpValue . ', ENT_QUOTES | ENT_HTML5, \'UTF-8\') . "\\"';
                    }
                } else {
                    // Static value
                    if ($needsUrlProcessing && is_string($attrValue)) {
                        // Process URL at compile time for static values, or generate runtime code
                        $output .= ' ' . $attrName . '=\\"" . htmlspecialchars(processUrl(' . var_export($attrValue, true) . ', $__lang), ENT_QUOTES | ENT_HTML5, \'UTF-8\') . "\\"';
                    } else {
                        $output .= ' ' . $attrName . '=\\"" . htmlspecialchars(';
                        $output .= var_export($attrValue, true);
                        $output .= ', ENT_QUOTES | ENT_HTML5, \'UTF-8\') . "\\"';
                    }
                }
            }
            
            $output .= '>";' . "\n";
            }
        
        // Void elements don't have children or closing tags
        $voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 
                         'link', 'meta', 'param', 'source', 'track', 'wbr'];
        $isVoid = in_array(strtolower($tag), $voidElements);
        
        // Render children
        if (!$isVoid && !empty($children)) {
            foreach ($children as $child) {
                $output .= $this->compileNode($child, $echo);
            }
        }
        
        // Closing tag
        if (!$isVoid) {
            $output .= $prefix . '"</' . $tag . '>";' . "\n";
        }
        
        return $output;
    }
    
    /**
     * Compile a component node (inline component structure)
     */
    private function compileComponent(array $node, bool $echo = false): string {
        $componentName = $node['component'] ?? null;
        $data = $node['data'] ?? [];
        
        if (empty($componentName)) {
            return "// Missing component name\n";
        }
        
        // Load component JSON from development location
        $componentPath = PROJECT_PATH . '/templates/model/json/components/' . $componentName . '.json';
        
        if (!file_exists($componentPath)) {
            return "// Component not found: {$componentName}\n";
        }
        
        $componentJson = @file_get_contents($componentPath);
        if ($componentJson === false) {
            return "// Failed to read component: {$componentName}\n";
        }
        
        $componentStructure = json_decode($componentJson, true);
        
        if (!$componentStructure) {
            return "// Invalid component JSON: {$componentName}\n";
        }
        
        // Process system placeholders in data FIRST
        $data = $this->processDataPlaceholders($data);
        
        // Then process component template with data
        $processedComponent = $this->processComponentTemplate($componentStructure, $data);
        
        // Compile the processed component
        return $this->compileNode($processedComponent, $echo);
    }
    
    /**
     * Process component template by replacing {{placeholders}} with data
     */
    private function processComponentTemplate($template, array $data) {
        if (is_string($template)) {
            // Replace {{placeholder}} with actual value
            return preg_replace_callback('/\{\{(\w+)\}\}/', function($matches) use ($data) {
                $key = $matches[1];
                return $data[$key] ?? $matches[0]; // Keep placeholder if no data
            }, $template);
        }
        
        if (is_array($template)) {
            $processed = [];
            foreach ($template as $key => $value) {
                $processed[$key] = $this->processComponentTemplate($value, $data);
            }
            return $processed;
        }
        
        return $template;
    }
    
    /**
     * Process system placeholders in component data
     * Replaces {{__placeholder}} with special marker for later conversion
     */
    private function processDataPlaceholders($data) {
        if (is_string($data)) {
            // Check if contains system placeholders
            if (strpos($data, '{{__') !== false) {
                // Keep the placeholder - will be converted to PHP in compileTagNode
                return $data;
            }
            return $data;
        }
        
        if (is_array($data)) {
            $processed = [];
            foreach ($data as $key => $value) {
                $processed[$key] = $this->processDataPlaceholders($value);
            }
            return $processed;
        }
        
        return $data;
    }
    
    /**
     * Convert system placeholders in string to PHP variable concatenation
     * Handles both {{__placeholder}} and {{__placeholder;param=value}} syntax
     * Example: "/en/{{__current_page}}" becomes '"/en/" . $__current_page'
     * Example: "{{__current_page;lang=en}}" becomes buildLanguageSwitchUrl('en')
     */
    private function convertPlaceholdersToPhp(string $value): string {
        // Split by placeholders (including those with parameters)
        $parts = preg_split('/(\{\{__\w+(?:;[^}]+)?\}\})/', $value, -1, PREG_SPLIT_DELIM_CAPTURE);
        $phpParts = [];
        
        foreach ($parts as $part) {
            if (empty($part)) continue;
            
            if (preg_match('/\{\{(__\w+)(?:;([^}]+))?\}\}/', $part, $matches)) {
                // System placeholder
                $key = $matches[1];
                $paramString = $matches[2] ?? '';
                
                // Special handling for __current_page with lang parameter
                if ($key === '__current_page' && !empty($paramString) && strpos($paramString, 'lang=') !== false) {
                    // Parse the lang parameter
                    preg_match('/lang=(\w+)/', $paramString, $langMatch);
                    $targetLang = $langMatch[1] ?? 'en';
                    // Generate call to buildLanguageSwitchUrl function
                    $phpParts[] = "buildLanguageSwitchUrl(" . var_export($targetLang, true) . ")";
                } else {
                    // Regular placeholder - convert to PHP variable
                    $phpParts[] = '$' . $key;
                }
            } else {
                // Static string
                $phpParts[] = var_export($part, true);
            }
        }

        return implode(' . ', $phpParts);
    }

    /**
     * Transform {{call:functionName:arg1,arg2}} syntax to QS.functionName('arg1', 'arg2')
     * Same logic as JsonToHtmlRenderer::transformCallSyntax()
     * 
     * Special keywords (not quoted): event, this
     * 
     * @param string $value The attribute value containing {{call:...}} placeholders
     * @return string Transformed JavaScript code
     */
    private function transformCallSyntax(string $value): string {
        return preg_replace_callback(
            '/\{\{call:([a-zA-Z][a-zA-Z0-9]*)(:[^}]*)?\}\}/',
            function ($matches) {
                $functionName = $matches[1];
                $argsString = isset($matches[2]) ? substr($matches[2], 1) : '';
                
                // Get allowed function names dynamically (core + custom)
                $allowedFunctions = $this->getAllowedJsFunctions();
                
                if (!in_array($functionName, $allowedFunctions, true)) {
                    return '/* invalid function */';
                }
                
                if (empty($argsString)) {
                    return "QS.{$functionName}()";
                }
                
                // Special keywords that should not be quoted (JS variables)
                $jsKeywords = ['event', 'this'];
                
                $args = array_map('trim', explode(',', $argsString));
                $quotedArgs = array_map(function($arg) use ($jsKeywords) {
                    if (in_array($arg, $jsKeywords, true)) {
                        return $arg;
                    }
                    $escaped = str_replace("'", "\\'", $arg);
                    return "'{$escaped}'";
                }, $args);
                
                return "QS.{$functionName}(" . implode(', ', $quotedArgs) . ")";
            },
            $value
        );
    }

    /**
     * Get all allowed JS function names (core + custom)
     * Cached for performance within single compile
     * 
     * @return array
     */
    private function getAllowedJsFunctions(): array {
        static $allowedFunctions = null;
        
        if ($allowedFunctions === null) {
            // Core functions (always available)
            $allowedFunctions = [
                'show', 'hide', 'toggle', 'toggleHide', 'addClass', 'removeClass',
                'setValue', 'redirect', 'filter', 'scrollTo', 'focus', 'blur', 'fetch',
                'renderList', 'toast'
            ];
            
            // Add custom functions if JsFunctionManager is available
            $managerPath = SECURE_FOLDER_PATH . '/src/classes/JsFunctionManager.php';
            if (file_exists($managerPath)) {
                require_once $managerPath;
                $manager = new \JsFunctionManager();
                $customFuncs = $manager->getCustomFunctions();
                foreach ($customFuncs as $func) {
                    $allowedFunctions[] = $func['name'];
                }
            }
        }
        
        return $allowedFunctions;
    }

    /**
     * Validate that a transformed event handler only contains safe QS.* calls
     * Same logic as JsonToHtmlRenderer::isValidTransformedHandler()
     * 
     * @param string $handler The transformed handler string
     * @return bool True if safe, false if suspicious
     */
    private function isValidTransformedHandler(string $handler): bool {
        $stripped = preg_replace('/QS\.[a-zA-Z]+\([^)]*\)/', '', $handler);
        $stripped = preg_replace('/[;\s]/', '', $stripped);
        $stripped = preg_replace('/\/\*[^*]*\*\//', '', $stripped);
        
        return empty($stripped);
    }

}